package workflow

import (
	"context"
	"fmt"
	"log/slog"
	"math/rand/v2"
	"strings"
	"time"

	"github.com/deepnoodle-ai/workflow/retry"
	"github.com/deepnoodle-ai/workflow/script"
	"github.com/deepnoodle-ai/workflow/state"
)

// ActivityExecutor provides a simplified interface for executing activities with logging and checkpointing
type ActivityExecutor interface {
	// ExecuteActivity runs an activity with automatic logging and checkpointing
	// In the new path-local state system, activities work directly with path state
	ExecuteActivity(ctx context.Context, stepName, pathID string, activity Activity, params map[string]interface{}, pathState *PathLocalState) (result interface{}, err error)
}

// PathLocalState provides activities with direct access to path-local state
type PathLocalState struct {
	inputs    map[string]any
	variables map[string]any
}

func NewPathLocalState(inputs, variables map[string]any) *PathLocalState {
	return &PathLocalState{
		inputs:    copyMapAny(inputs),
		variables: copyMapAny(variables),
	}
}

func (s *PathLocalState) GetInputs() map[string]any {
	return copyMapAny(s.inputs)
}

func (s *PathLocalState) GetVariables() map[string]any {
	return copyMapAny(s.variables)
}

func (s *PathLocalState) SetVariable(key string, value any) {
	s.variables[key] = value
}

func (s *PathLocalState) DeleteVariable(key string) {
	delete(s.variables, key)
}

// ApplyPatches is provided for compatibility but works directly on local state
func (s *PathLocalState) ApplyPatches(patches []state.Patch) {
	for _, patch := range patches {
		if patch.Delete {
			delete(s.variables, patch.Variable)
		} else {
			s.variables[patch.Variable] = patch.Value
		}
	}
}

// PathOptions contains all dependencies needed by a Path, injected at construction
type PathOptions struct {
	Workflow           *Workflow
	ActivityRegistry   map[string]Activity
	Logger             *slog.Logger
	Formatter          WorkflowFormatter
	Inputs             map[string]any // Initial inputs (readonly)
	Variables          map[string]any // Initial variables (will be copied)
	ActivityExecutor   ActivityExecutor
	UpdatesChannel     chan<- PathSnapshot
	ScriptCompiler     script.Compiler
	ExecutionCallbacks ExecutionCallbacks
}

// PathSpec specifies how to create a new path (ID generated by Execution)
type PathSpec struct {
	Step      *Step
	Variables map[string]any
}

// PathSnapshot represents a snapshot of path state for communication
type PathSnapshot struct {
	PathID     string
	Status     PathStatus
	StepName   string
	StepOutput any
	NewPaths   []PathSpec
	Error      error
	Timestamp  time.Time
	StartTime  time.Time
	EndTime    time.Time
}

// Path represents an execution path through a workflow with owned state
type Path struct {
	// Owned state
	id          string
	currentStep *Step
	status      PathStatus
	stepOutputs map[string]any
	startTime   time.Time
	endTime     time.Time

	// Path-local state (owned by this path)
	inputs    map[string]any // Readonly copy of workflow inputs
	variables map[string]any // Mutable path-local variables

	// Injected dependencies (immutable after construction)
	workflow           *Workflow
	activityRegistry   map[string]Activity
	activityExecutor   ActivityExecutor
	logger             *slog.Logger
	formatter          WorkflowFormatter
	updates            chan<- PathSnapshot
	scriptCompiler     script.Compiler
	executionCallbacks ExecutionCallbacks
}

// NewPath creates a new execution path with options pattern
func NewPath(id string, step *Step, opts PathOptions) *Path {
	// Copy inputs and variables to create path-local state
	localInputs := make(map[string]any)
	for k, v := range opts.Inputs {
		localInputs[k] = v
	}

	localVariables := make(map[string]any)
	for k, v := range opts.Variables {
		localVariables[k] = v
	}

	return &Path{
		id:                 id,
		currentStep:        step,
		status:             PathStatusPending,
		stepOutputs:        make(map[string]any),
		startTime:          time.Now(),
		inputs:             localInputs,
		variables:          localVariables,
		workflow:           opts.Workflow,
		activityRegistry:   opts.ActivityRegistry,
		activityExecutor:   opts.ActivityExecutor,
		logger:             opts.Logger.With("path_id", id),
		formatter:          opts.Formatter,
		updates:            opts.UpdatesChannel,
		scriptCompiler:     opts.ScriptCompiler,
		executionCallbacks: opts.ExecutionCallbacks,
	}
}

// ID returns the path ID
func (p *Path) ID() string {
	return p.id
}

// CurrentStep returns the current step in the path
func (p *Path) CurrentStep() *Step {
	return p.currentStep
}

// Variables returns a copy of the path's current variables
func (p *Path) Variables() map[string]any {
	return copyMapAny(p.variables)
}

// Snapshot returns a snapshot of the current path state
func (p *Path) Snapshot() PathSnapshot {
	stepOutputs := make(map[string]any)
	for k, v := range p.stepOutputs {
		stepOutputs[k] = v
	}
	return PathSnapshot{
		PathID:    p.id,
		Status:    p.status,
		StepName:  p.currentStep.Name,
		StartTime: p.startTime,
		EndTime:   p.endTime,
		Timestamp: time.Now(),
	}
}

// Run executes the path until completion or error
func (p *Path) Run(ctx context.Context) error {
	p.status = PathStatusRunning

	for {
		// Check for context cancellation
		select {
		case <-ctx.Done():
			return ctx.Err()
		default:
		}

		// Execute the current step
		currentStep := p.currentStep
		result, err := p.executeStep(ctx, currentStep)
		if err != nil {
			p.status = PathStatusFailed
			p.endTime = time.Now()
			p.updates <- PathSnapshot{
				PathID:    p.id,
				Status:    p.status,
				StepName:  currentStep.Name,
				Error:     err,
				StartTime: p.startTime,
				EndTime:   p.endTime,
				Timestamp: time.Now(),
			}
			return err
		}

		// Store step output
		p.stepOutputs[currentStep.Name] = result

		// Note: No need to apply patches - variables are updated directly in executeStep

		// Handle path branching (state is now current)
		newPathSpecs, err := p.handleBranching(ctx)
		if err != nil {
			p.status = PathStatusFailed
			p.endTime = time.Now()
			p.updates <- PathSnapshot{
				PathID:    p.id,
				Status:    p.status,
				StepName:  currentStep.Name,
				Error:     err,
				StartTime: p.startTime,
				EndTime:   p.endTime,
				Timestamp: time.Now(),
			}
			return err
		}

		// This path is complete if there are:
		//  A) no new paths
		//  B) multiple paths (branching)
		isDone := len(newPathSpecs) == 0 || len(newPathSpecs) > 1

		if isDone {
			p.status = PathStatusCompleted
			p.endTime = time.Now()
		}

		// Send snapshot update
		var pathsToCreate []PathSpec
		if len(newPathSpecs) > 1 {
			pathsToCreate = newPathSpecs
		}

		p.updates <- PathSnapshot{
			PathID:     p.id,
			Status:     p.status,
			StepName:   currentStep.Name,
			StepOutput: result,
			NewPaths:   pathsToCreate,
			StartTime:  p.startTime,
			EndTime:    p.endTime,
			Timestamp:  time.Now(),
		}

		if isDone {
			return nil
		}

		// Continue with the single path
		p.currentStep = newPathSpecs[0].Step
	}
}

// executeStep executes a single workflow step
func (p *Path) executeStep(ctx context.Context, step *Step) (any, error) {
	p.logger.Debug("executing step", "step_name", step.Name)

	// Print step start if formatter is available
	if p.formatter != nil {
		p.formatter.PrintStepStart(step.Name, step.Activity)
	}

	var result any
	var err error

	// Execute with retry logic if configured
	retryConfig := step.Retry
	if retryConfig != nil && retryConfig.MaxRetries > 0 {
		result, err = p.executeStepWithRetry(ctx, step, retryConfig)
	} else {
		result, err = p.executeStepOnce(ctx, step)
	}

	if err != nil {
		// Print step error if formatter is available
		if p.formatter != nil {
			p.formatter.PrintStepError(step.Name, err)
		}
		return nil, err
	}

	// Store step result in path-local state if not an each step (each steps handle their own storage)
	if step.Each == nil {
		// Store the result in a state variable if specified
		if varName := step.Store; varName != "" {
			// Strip "state." prefix if present
			varName = strings.TrimPrefix(varName, "state.")

			// Store the result directly in path variables
			var valueToStore interface{}
			if result != nil {
				valueToStore = result
			}
			p.variables[varName] = valueToStore
		}
	}

	// Print step output if formatter is available
	if p.formatter != nil {
		p.formatter.PrintStepOutput(step.Name, result.(string))
	}

	return result, nil
}

// copyMapAny creates a shallow copy of a map[string]any
func copyMapAny(m map[string]any) map[string]any {
	if m == nil {
		return nil
	}
	result := make(map[string]any, len(m))
	for k, v := range m {
		result[k] = v
	}
	return result
}

// executeStepOnce executes a step once without retry logic
func (p *Path) executeStepOnce(ctx context.Context, step *Step) (any, error) {
	// Handle steps with "each" blocks
	if step.Each != nil {
		return p.executeStepEach(ctx, step)
	}

	// Use Activity interface
	activityName := step.Activity
	if activityName == "" {
		return nil, fmt.Errorf("no activity specified for step %q", step.Name)
	}

	// Look up activity in registry
	activity, ok := p.activityRegistry[activityName]
	if !ok {
		return nil, fmt.Errorf("activity %q not found for step %q", activityName, step.Name)
	}

	// Prepare parameters by evaluating templates and script expressions
	params, err := p.buildStepParameters(ctx, step, nil)
	if err != nil {
		return nil, err
	}

	// Execute activity through the ActivityExecutor with path-local state
	pathState := NewPathLocalState(p.inputs, p.variables)
	result, err := p.activityExecutor.ExecuteActivity(ctx, step.Name, p.id, activity, params, pathState)
	if err != nil {
		return nil, fmt.Errorf("activity %q execution failed on step %q: %w",
			activityName, step.Name, err)
	}

	// Update path variables from the activity execution
	p.variables = copyMapAny(pathState.variables)

	return result, nil
}

// executeStepWithRetry executes a step with retry logic
func (p *Path) executeStepWithRetry(ctx context.Context, step *Step, retryConfig *RetryConfig) (any, error) {
	var lastErr error

	for attempt := 0; attempt <= retryConfig.MaxRetries; attempt++ {
		if attempt > 0 {
			// Calculate backoff delay
			delay := calculateBackoffDelay(attempt, retryConfig)

			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			case <-time.After(delay):
			}

			p.logger.Info("retrying step",
				"step_name", step.Name,
				"attempt", attempt+1,
				"max_attempts", retryConfig.MaxRetries+1,
				"delay", delay)
		}

		// Create timeout context if configured
		stepCtx := ctx
		var cancel context.CancelFunc
		if retryConfig.Timeout > 0 {
			stepCtx, cancel = context.WithTimeout(ctx, retryConfig.Timeout)
		}

		var result any
		result, lastErr = p.executeStepOnce(stepCtx, step)

		if cancel != nil {
			cancel()
		}

		if lastErr == nil {
			if attempt > 0 {
				p.logger.Info("step retry succeeded",
					"step_name", step.Name,
					"successful_attempt", attempt+1)
			}
			return result, nil
		}

		// Check if error is recoverable
		if !retry.IsRecoverable(lastErr) {
			p.logger.Info("step failed with non-recoverable error, not retrying",
				"step_name", step.Name,
				"error", lastErr.Error())
			return nil, lastErr
		}

		p.logger.Warn("step failed with recoverable error",
			"step_name", step.Name,
			"attempt", attempt+1,
			"error", lastErr.Error())
	}

	return nil, fmt.Errorf("step %q failed after %d attempts: %w",
		step.Name, retryConfig.MaxRetries+1, lastErr)
}

// applyVariableUpdates function removed - no longer needed in path-local state system

// handleBranching evaluates conditions and creates path specs for branching
func (p *Path) handleBranching(ctx context.Context) ([]PathSpec, error) {
	edges := p.currentStep.Next
	if len(edges) == 0 {
		return nil, nil // No outgoing edges means this path is complete
	}

	// Evaluate conditions and collect matching edges (state is now current)
	var matchingEdges []*Edge
	for _, edge := range edges {
		if edge.Condition == "" {
			matchingEdges = append(matchingEdges, edge)
			continue
		}
		match, err := p.evaluateCondition(ctx, edge.Condition)
		if err != nil {
			return nil, fmt.Errorf("failed to evaluate condition %q in step %q: %w",
				edge.Condition, p.currentStep.Name, err)
		}
		if match {
			matchingEdges = append(matchingEdges, edge)
		}
	}

	// Create path specs for each matching edge, copying current path's state
	var pathSpecs []PathSpec
	for _, edge := range matchingEdges {
		nextStep, ok := p.workflow.GetStep(edge.Step)
		if !ok {
			return nil, fmt.Errorf("next step not found: %s", edge.Step)
		}
		// Copy current path's variables to the new path
		stateCopy := copyMapAny(p.variables)
		pathSpecs = append(pathSpecs, PathSpec{
			Step:      nextStep,
			Variables: stateCopy,
		})
	}
	return pathSpecs, nil
}

// evaluateCondition evaluates a workflow condition
func (p *Path) evaluateCondition(ctx context.Context, condition string) (bool, error) {
	// Handle simple boolean conditions
	switch strings.ToLower(strings.TrimSpace(condition)) {
	case "true":
		return true, nil
	case "false":
		return false, nil
	}

	// Handle script expressions wrapped in $()
	codeStr := condition
	if strings.HasPrefix(codeStr, "$(") && strings.HasSuffix(codeStr, ")") {
		codeStr = strings.TrimPrefix(codeStr, "$(")
		codeStr = strings.TrimSuffix(codeStr, ")")
	}

	// Compile the script
	compiledScript, err := p.scriptCompiler.Compile(ctx, codeStr)
	if err != nil {
		return false, fmt.Errorf("failed to compile condition: %w", err)
	}

	// Evaluate the condition with current state
	result, err := compiledScript.Evaluate(ctx, p.buildScriptGlobals())
	if err != nil {
		return false, fmt.Errorf("failed to evaluate condition: %w", err)
	}

	// Convert result to boolean
	return result.IsTruthy(), nil
}

// evaluateTemplate evaluates a template string
func (p *Path) evaluateTemplate(ctx context.Context, template string) (string, error) {
	if strings.HasPrefix(template, "$(") && strings.HasSuffix(template, ")") {
		template = strings.TrimPrefix(template, "$(")
		template = strings.TrimSuffix(template, ")")
	}
	tmpl, err := script.NewTemplate(p.scriptCompiler, template)
	if err != nil {
		return "", fmt.Errorf("failed to compile template: %w", err)
	}
	return tmpl.Eval(ctx, p.buildScriptGlobals())
}

// executeStepEach handles the execution of a step that has an each block
func (p *Path) executeStepEach(ctx context.Context, step *Step) (any, error) {
	each := step.Each

	// Resolve the items to iterate over
	items, err := p.resolveEachItems(ctx, each)
	if err != nil {
		return nil, fmt.Errorf("failed to resolve each items: %w", err)
	}

	// Execute the step for each item and capture the results
	results := make([]any, 0, len(items))

	// Look up activity in registry
	activityName := step.Activity
	if activityName == "" {
		return nil, fmt.Errorf("no activity specified for step %q", step.Name)
	}

	activity, ok := p.activityRegistry[activityName]
	if !ok {
		return nil, fmt.Errorf("activity %q not found for step %q", activityName, step.Name)
	}

	// Execute for each item
	for _, item := range items {
		// Prepare additional parameters for this iteration
		additionalParams := make(map[string]interface{})
		if each.As != "" {
			additionalParams[each.As] = item
		}

		// Prepare parameters for this iteration
		params, err := p.buildStepParameters(ctx, step, additionalParams)
		if err != nil {
			return nil, err
		}

		// Execute activity for this item
		pathState := NewPathLocalState(p.inputs, p.variables)
		result, err := p.activityExecutor.ExecuteActivity(ctx, step.Name, p.id, activity, params, pathState)
		if err != nil {
			return nil, err
		}

		// Update path variables from this iteration
		p.variables = copyMapAny(pathState.variables)
		results = append(results, result)
	}

	// Store result directly in path variables if specified
	if step.Store != "" {
		varName := strings.TrimPrefix(step.Store, "state.")
		p.variables[varName] = results
	}

	return results, nil
}

// resolveEachItems resolves the array of items from either a direct array or a Risor expression
func (p *Path) resolveEachItems(ctx context.Context, each *Each) ([]any, error) {
	// Array of strings
	if strArray, ok := each.Items.([]string); ok {
		var items []any
		for _, item := range strArray {
			items = append(items, item)
		}
		return items, nil
	}

	// Array of any
	if items, ok := each.Items.([]any); ok {
		return items, nil
	}

	// Handle script expression
	if codeStr, ok := each.Items.(string); ok {
		if strings.HasPrefix(codeStr, "$(") && strings.HasSuffix(codeStr, ")") {
			return p.evaluateExpression(ctx, codeStr)
		}
	}
	return nil, fmt.Errorf("unsupported value for 'each' block (got %T)", each.Items)
}

// evaluateExpression evaluates a Risor expression and returns the result as an array
func (p *Path) evaluateExpression(ctx context.Context, codeStr string) ([]any, error) {
	code := strings.TrimSuffix(strings.TrimPrefix(codeStr, "$("), ")")
	compiledScript, err := p.scriptCompiler.Compile(ctx, code)
	if err != nil {
		p.logger.Error("failed to compile 'each' expression", "error", err)
		return nil, fmt.Errorf("failed to compile expression: %w", err)
	}
	result, err := compiledScript.Evaluate(ctx, p.buildScriptGlobals())
	if err != nil {
		p.logger.Error("failed to evaluate 'each' expression", "error", err)
		return nil, fmt.Errorf("failed to evaluate expression: %w", err)
	}
	return result.Items()
}

// calculateBackoffDelay calculates the backoff delay for retry attempts
func calculateBackoffDelay(attempt int, retryConfig *RetryConfig) time.Duration {
	baseDelay := retryConfig.BaseDelay
	if baseDelay <= 0 {
		baseDelay = 1 * time.Second // Default base delay
	}

	// Exponential backoff with jitter
	delay := time.Duration(float64(baseDelay) * float64(int64(1)<<(attempt-1)))

	// Apply max delay cap if configured
	if retryConfig.MaxDelay > 0 && delay > retryConfig.MaxDelay {
		delay = retryConfig.MaxDelay
	}

	// Add 10% jitter to prevent thundering herd
	jitter := time.Duration(float64(delay) * 0.1 * (2*rand.Float64() - 1))
	delay += jitter

	if delay < 0 {
		delay = baseDelay
	}

	return delay
}

// buildScriptGlobals creates globals used for script execution
func (p *Path) buildScriptGlobals() map[string]any {
	return map[string]any{
		"inputs": copyMapAny(p.inputs),
		"state":  copyMapAny(p.variables),
	}
}

// buildStepParameters creates a parameter map by evaluating templates and script expressions
func (p *Path) buildStepParameters(ctx context.Context, step *Step, additionalParams map[string]interface{}) (map[string]interface{}, error) {
	params := make(map[string]interface{})

	// Add step parameters
	for name, value := range step.Parameters {
		evaluated, err := p.evaluateParameterValue(ctx, value, step.Name, name)
		if err != nil {
			return nil, err
		}
		params[name] = evaluated
	}

	// Add any additional parameters
	for name, value := range additionalParams {
		params[name] = value
	}

	return params, nil
}

// evaluateParameterValue evaluates a parameter value, handling both script expressions and templates
func (p *Path) evaluateParameterValue(ctx context.Context, value interface{}, stepName, paramName string) (interface{}, error) {
	strValue, ok := value.(string)
	if !ok {
		return value, nil
	}

	// Handle script expressions $(code) - these return actual values, not strings
	if strings.HasPrefix(strValue, "$(") && strings.HasSuffix(strValue, ")") {
		codeStr := strings.TrimPrefix(strValue, "$(")
		codeStr = strings.TrimSuffix(codeStr, ")")

		// Compile and evaluate the script
		compiledScript, err := p.scriptCompiler.Compile(ctx, codeStr)
		if err != nil {
			return nil, fmt.Errorf("failed to compile script expression in parameter %q of step %q: %w",
				paramName, stepName, err)
		}

		result, err := compiledScript.Evaluate(ctx, p.buildScriptGlobals())
		if err != nil {
			return nil, fmt.Errorf("failed to evaluate script expression in parameter %q of step %q: %w",
				paramName, stepName, err)
		}

		// Return the actual value from the script
		return result.Value(), nil
	}

	// Handle template strings ${variable} - these return strings
	if strings.Contains(strValue, "${") {
		evaluated, err := p.evaluateTemplate(ctx, strValue)
		if err != nil {
			return nil, fmt.Errorf("failed to evaluate parameter template %q in step %q: %w",
				paramName, stepName, err)
		}
		return evaluated, nil
	}

	// Return value as-is
	return value, nil
}
