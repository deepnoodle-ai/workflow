package workflow

import (
	"context"
	"fmt"
	"log/slog"
	"math/rand/v2"
	"strings"
	"time"

	"github.com/deepnoodle-ai/workflow/script"
)

// catchErrorSentinel is a sentinel value used to indicate that a catch handler
// executed and the current step has been updated.
const catchErrorSentinel = "__CATCH_HANDLED__"

// ActivityExecutor provides a simplified interface for executing activities with logging and checkpointing
type ActivityExecutor interface {
	// ExecuteActivity runs an activity with automatic logging and checkpointing
	// In the new path-local state system, activities work directly with path state
	ExecuteActivity(ctx context.Context, stepName, pathID string, activity Activity, params map[string]interface{}, pathState *PathLocalState) (result interface{}, err error)
}

// PathOptions contains all dependencies needed by a Path, injected at construction
type PathOptions struct {
	Workflow           *Workflow
	ActivityRegistry   map[string]Activity
	Logger             *slog.Logger
	Formatter          WorkflowFormatter
	Inputs             map[string]any // Initial inputs (readonly)
	Variables          map[string]any // Initial variables (will be copied)
	ActivityExecutor   ActivityExecutor
	UpdatesChannel     chan<- PathSnapshot
	ScriptCompiler     script.Compiler
	ExecutionCallbacks ExecutionCallbacks
}

// PathSpec specifies how to create a new path (ID generated by Execution)
type PathSpec struct {
	Step      *Step
	Variables map[string]any
	Name      string // Optional name for the path from Edge.Path
}

// PathSnapshot represents a snapshot of path state for communication
type PathSnapshot struct {
	PathID      string
	Status      ExecutionStatus
	StepName    string
	StepOutput  any
	NewPaths    []PathSpec
	Error       error
	Timestamp   time.Time
	StartTime   time.Time
	EndTime     time.Time
	JoinRequest *JoinRequest // New field for join requests
}

// JoinRequest indicates a path is waiting at a join step
type JoinRequest struct {
	StepName    string         `json:"step_name"`
	Config      *JoinConfig    `json:"config"`
	Variables   map[string]any `json:"variables"`
	StepOutputs map[string]any `json:"step_outputs"`
}

// Path represents an execution path through a workflow with owned state
type Path struct {
	// Owned state
	id          string
	currentStep *Step
	status      ExecutionStatus
	stepOutputs map[string]any
	startTime   time.Time
	endTime     time.Time
	state       *PathLocalState

	// Join coordination
	resumeFromJoin chan struct{} // Channel to signal resumption from join

	// Injected dependencies (immutable after construction)
	workflow           *Workflow
	activityRegistry   map[string]Activity
	activityExecutor   ActivityExecutor
	logger             *slog.Logger
	formatter          WorkflowFormatter
	updates            chan<- PathSnapshot
	scriptCompiler     script.Compiler
	executionCallbacks ExecutionCallbacks
}

// NewPath creates a new execution path with options pattern
func NewPath(id string, step *Step, opts PathOptions) *Path {
	logger := opts.Logger
	if logger == nil {
		logger = NewLogger()
	}
	logger = logger.With("path_id", id)

	state := NewPathLocalState(opts.Inputs, opts.Variables)

	return &Path{
		id:                 id,
		currentStep:        step,
		status:             ExecutionStatusPending,
		stepOutputs:        make(map[string]any),
		state:              state,
		resumeFromJoin:     make(chan struct{}, 1), // Buffered channel for join resumption
		workflow:           opts.Workflow,
		activityRegistry:   opts.ActivityRegistry,
		activityExecutor:   opts.ActivityExecutor,
		logger:             logger,
		formatter:          opts.Formatter,
		updates:            opts.UpdatesChannel,
		scriptCompiler:     opts.ScriptCompiler,
		executionCallbacks: opts.ExecutionCallbacks,
	}
}

// ID returns the path ID
func (p *Path) ID() string {
	return p.id
}

// CurrentStep returns the current step in the path
func (p *Path) CurrentStep() *Step {
	return p.currentStep
}

// Variables returns a copy of the path's current variables
func (p *Path) Variables() map[string]any {
	return copyMap(p.state.variables)
}

// Run executes the path until completion or error
func (p *Path) Run(ctx context.Context) error {
	p.status = ExecutionStatusRunning
	p.startTime = time.Now()

	for {
		// Check for context cancellation
		select {
		case <-ctx.Done():
			return ctx.Err()
		default:
		}

		// Execute the current step
		currentStep := p.currentStep
		result, err := p.executeStep(ctx, currentStep)
		if err != nil {
			p.status = ExecutionStatusFailed
			p.endTime = time.Now()
			p.updates <- PathSnapshot{
				PathID:    p.id,
				Status:    p.status,
				StepName:  currentStep.Name,
				Error:     err,
				StartTime: p.startTime,
				EndTime:   p.endTime,
				Timestamp: time.Now(),
			}
			return err
		}

		// Handle join requests specially
		if result == "join_requested" {
			// Path is now waiting at a join, mark as completed but waiting
			p.status = ExecutionStatusCompleted
			p.endTime = time.Now()
			// Join request was already sent in handleJoinStep
			return nil
		}

		// Handle join completion - continue normal execution
		if result == "join_completed" {
			// The join completed and this path was resumed
			// Continue with normal execution flow (don't store output for join step)
			continue
		}

		// Handle catch handler results specially
		if result == catchErrorSentinel {
			// Catch handler was executed, current step has been updated
			// Continue with the new step without storing output or handling branching
			continue
		}

		// Store step output
		p.stepOutputs[currentStep.Name] = result

		// Handle path branching (state is now current)
		newPathSpecs, err := p.handleBranching(ctx)
		if err != nil {
			p.status = ExecutionStatusFailed
			p.endTime = time.Now()
			p.updates <- PathSnapshot{
				PathID:    p.id,
				Status:    p.status,
				StepName:  currentStep.Name,
				Error:     err,
				StartTime: p.startTime,
				EndTime:   p.endTime,
				Timestamp: time.Now(),
			}
			return err
		}

		// This path is complete if there are:
		//  A) no new paths
		//  B) multiple paths (branching)
		//  C) single path with a PathName that differs from current path (named branch to different path)
		hasNamedPaths := len(newPathSpecs) > 0 && newPathSpecs[0].Name != ""
		samePathName := hasNamedPaths && newPathSpecs[0].Name == p.id
		isDone := len(newPathSpecs) == 0 || len(newPathSpecs) > 1 || (hasNamedPaths && !samePathName)

		if isDone {
			p.status = ExecutionStatusCompleted
			p.endTime = time.Now()
		}

		// Send snapshot update
		var pathsToCreate []PathSpec
		if len(newPathSpecs) > 1 || (hasNamedPaths && !samePathName) {
			pathsToCreate = newPathSpecs
		}

		p.updates <- PathSnapshot{
			PathID:     p.id,
			Status:     p.status,
			StepName:   currentStep.Name,
			StepOutput: result,
			NewPaths:   pathsToCreate,
			StartTime:  p.startTime,
			EndTime:    p.endTime,
			Timestamp:  time.Now(),
		}

		if isDone {
			return nil
		}

		// Continue with the single path (only if it's unnamed)
		p.currentStep = newPathSpecs[0].Step
	}
}

// executeStep executes a single workflow step
func (p *Path) executeStep(ctx context.Context, step *Step) (any, error) {
	p.logger.Debug("executing step", "step_name", step.Name)

	// Check if this is a join step
	if step.Join != nil {
		return p.handleJoinStep(ctx, step)
	}

	// Print step start if formatter is available
	if p.formatter != nil {
		p.formatter.PrintStepStart(step.Name, step.Activity)
	}

	var result any
	var err error

	// Execute with retry logic if configured
	retryConfigs := step.Retry
	if len(retryConfigs) > 0 {
		result, err = p.executeStepWithRetry(ctx, step, retryConfigs)
	} else {
		result, err = p.executeStepOnce(ctx, step)
	}

	if err != nil {
		// Print step error if formatter is available
		if p.formatter != nil {
			p.formatter.PrintStepError(step.Name, err)
		}
		// Try catch handlers for any step failure
		if len(step.Catch) > 0 {
			catchResult, catchErr := p.executeCatchHandler(step, err)
			if catchErr == nil {
				return catchResult, nil
			}
			// If catch handler also fails, return original error
		}
		return nil, err
	}

	// Store step result in path-local state if not an each step (each steps handle their own storage)
	if step.Each == nil {
		// Store the result in a state variable if specified
		if varName := step.Store; varName != "" {
			// Strip "state." prefix if present
			varName = strings.TrimPrefix(varName, "state.")

			// Store the result directly in path variables
			var valueToStore interface{}
			if result != nil {
				valueToStore = result
			}
			p.state.SetVariable(varName, valueToStore)
		}
	}

	// Print step output if formatter is available
	if p.formatter != nil {
		p.formatter.PrintStepOutput(step.Name, result)
	}

	return result, nil
}

// handleJoinStep handles execution of a join step
func (p *Path) handleJoinStep(ctx context.Context, step *Step) (any, error) {
	p.logger.Debug("handling join step", "step_name", step.Name, "join_config", step.Join)

	// Print step start if formatter is available
	if p.formatter != nil {
		p.formatter.PrintStepStart(step.Name, "join")
	}

	// Create join request with current path state
	joinRequest := &JoinRequest{
		StepName:    step.Name,
		Config:      step.Join,
		Variables:   copyMap(p.state.variables),
		StepOutputs: copyMap(p.stepOutputs),
	}

	// Send join request via path snapshot
	p.updates <- PathSnapshot{
		PathID:      p.id,
		Status:      ExecutionStatusWaiting, // Mark as waiting instead of running
		StepName:    step.Name,
		StepOutput:  nil, // No output yet
		JoinRequest: joinRequest,
		StartTime:   p.startTime,
		Timestamp:   time.Now(),
	}

	p.logger.Debug("sent join request, waiting for other paths", "step_name", step.Name)

	// Wait for the join to complete and this path to be resumed
	select {
	case <-ctx.Done():
		return nil, ctx.Err()
	case <-p.resumeFromJoin:
		p.logger.Debug("resumed from join", "step_name", step.Name)
		// The path's variables have been updated with merged state by the execution
		// Continue normally - the current step will be updated by the execution
		return "join_completed", nil
	}
}

// executeStepOnce executes a step once without retry logic
func (p *Path) executeStepOnce(ctx context.Context, step *Step) (any, error) {
	// Handle steps with "each" blocks
	if step.Each != nil {
		return p.executeStepEach(ctx, step)
	}

	// Use Activity interface
	activityName := step.Activity
	if activityName == "" {
		return nil, fmt.Errorf("no activity specified for step %q", step.Name)
	}

	// Look up activity in registry
	activity, ok := p.activityRegistry[activityName]
	if !ok {
		return nil, fmt.Errorf("activity %q not found for step %q", activityName, step.Name)
	}

	// Prepare parameters by evaluating templates and script expressions
	params, err := p.buildStepParameters(ctx, step)
	if err != nil {
		return nil, err
	}

	// Execute activity through the ActivityExecutor with path-local state
	result, err := p.activityExecutor.ExecuteActivity(ctx, step.Name, p.id, activity, params, p.state)
	if err != nil {
		return nil, fmt.Errorf("activity %q execution failed on step %q: %w",
			activityName, step.Name, err)
	}
	return result, nil
}

// executeStepWithRetry executes a step with retry logic using multiple retry configurations
func (p *Path) executeStepWithRetry(ctx context.Context, step *Step, retryConfigs []*RetryConfig) (any, error) {
	var lastErr error
	var activeRetryConfig *RetryConfig
	attempts := 0

	for {
		// Create timeout context using the active retry config's timeout
		stepCtx := ctx
		var cancel context.CancelFunc
		if activeRetryConfig != nil && activeRetryConfig.Timeout > 0 {
			stepCtx, cancel = context.WithTimeout(ctx, activeRetryConfig.Timeout)
		}

		result, err := p.executeStepOnce(stepCtx, step)

		if cancel != nil {
			cancel()
		}

		if err == nil {
			if lastErr != nil {
				p.logger.Info("step retry succeeded", "step_name", step.Name)
			}
			return result, nil
		}

		lastErr = err

		// If this is the first error, determine which retry configuration to use
		// for the entire retry sequence
		if activeRetryConfig == nil {
			activeRetryConfig = p.findMatchingRetryConfig(err, retryConfigs)
			if activeRetryConfig == nil {
				// No matching retry config found, return error immediately
				return nil, err
			}
		}

		// Check if we've exceeded max attempts for the active retry configuration
		if attempts >= activeRetryConfig.MaxRetries {
			p.logger.Info("step exceeded max retry attempts",
				"step_name", step.Name,
				"attempts", attempts+1,
				"max_attempts", activeRetryConfig.MaxRetries+1)
			return nil, err
		}

		// Increment attempt counter
		attempts++

		// Calculate and wait for backoff delay
		delay := p.calculateBackoffDelay(attempts, activeRetryConfig)

		p.logger.Info("retrying step",
			"step_name", step.Name,
			"attempt", attempts+1,
			"max_attempts", activeRetryConfig.MaxRetries+1,
			"delay", delay,
			"error_type", ClassifyError(err).Type)

		select {
		case <-ctx.Done():
			return nil, ctx.Err()
		case <-time.After(delay):
		}
	}
}

// handleBranching evaluates conditions and creates path specs for branching
func (p *Path) handleBranching(ctx context.Context) ([]PathSpec, error) {
	edges := p.currentStep.Next
	if len(edges) == 0 {
		return nil, nil // No outgoing edges means this path is complete
	}

	// Get the edge matching strategy for this step
	strategy := p.currentStep.GetEdgeMatchingStrategy()

	// Evaluate conditions and collect matching edges (state is now current)
	var matchingEdges []*Edge
	for _, edge := range edges {
		if edge.Condition == "" {
			matchingEdges = append(matchingEdges, edge)
		} else {
			match, err := p.evaluateCondition(ctx, edge.Condition)
			if err != nil {
				return nil, fmt.Errorf("failed to evaluate condition %q in step %q: %w",
					edge.Condition, p.currentStep.Name, err)
			}
			if match {
				matchingEdges = append(matchingEdges, edge)
			}
		}

		// If using "first" strategy and we found a match, stop here
		if strategy == EdgeMatchingFirst && len(matchingEdges) > 0 {
			break
		}
	}

	// Create path specs for each matching edge, copying current path's state
	var pathSpecs []PathSpec
	for _, edge := range matchingEdges {
		nextStep, ok := p.workflow.GetStep(edge.Step)
		if !ok {
			return nil, fmt.Errorf("next step not found: %s", edge.Step)
		}
		// Copy current path's variables to the new path
		pathSpecs = append(pathSpecs, PathSpec{
			Step:      nextStep,
			Variables: copyMap(p.state.variables),
			Name:      edge.Path,
		})
	}
	return pathSpecs, nil
}

// evaluateCondition evaluates a workflow condition
func (p *Path) evaluateCondition(ctx context.Context, condition string) (bool, error) {
	// Handle simple boolean conditions
	switch strings.ToLower(strings.TrimSpace(condition)) {
	case "true":
		return true, nil
	case "false":
		return false, nil
	}

	// Handle script expressions wrapped in $()
	codeStr := condition
	if strings.HasPrefix(codeStr, "$(") && strings.HasSuffix(codeStr, ")") {
		codeStr = strings.TrimPrefix(codeStr, "$(")
		codeStr = strings.TrimSuffix(codeStr, ")")
	}

	// Compile the script
	compiledScript, err := p.scriptCompiler.Compile(ctx, codeStr)
	if err != nil {
		return false, fmt.Errorf("failed to compile condition: %w", err)
	}

	// Evaluate the condition with current state
	result, err := compiledScript.Evaluate(ctx, p.buildScriptGlobals())
	if err != nil {
		return false, fmt.Errorf("failed to evaluate condition: %w", err)
	}

	// Convert result to boolean
	return result.IsTruthy(), nil
}

// evaluateTemplate evaluates a template string
func (p *Path) evaluateTemplate(ctx context.Context, template string) (string, error) {
	if strings.HasPrefix(template, "$(") && strings.HasSuffix(template, ")") {
		template = strings.TrimPrefix(template, "$(")
		template = strings.TrimSuffix(template, ")")
	}
	tmpl, err := script.NewTemplate(p.scriptCompiler, template)
	if err != nil {
		return "", fmt.Errorf("failed to compile template: %w", err)
	}
	return tmpl.Eval(ctx, p.buildScriptGlobals())
}

// executeStepEach handles the execution of a step that has an each block
func (p *Path) executeStepEach(ctx context.Context, step *Step) (any, error) {
	each := step.Each

	// Resolve the items to iterate over
	items, err := p.resolveEachItems(ctx, each)
	if err != nil {
		return nil, fmt.Errorf("failed to resolve each items: %w", err)
	}

	// Execute the step for each item and capture the results
	results := make([]any, 0, len(items))

	// Look up activity in registry
	activityName := step.Activity
	if activityName == "" {
		return nil, fmt.Errorf("no activity specified for step %q", step.Name)
	}

	activity, ok := p.activityRegistry[activityName]
	if !ok {
		return nil, fmt.Errorf("activity %q not found for step %q", activityName, step.Name)
	}

	// Remember the original value of the "as" variable
	var originalAsValue any
	if each.As != "" {
		if value, ok := p.state.GetVariable(each.As); ok {
			originalAsValue = value
		}
	}

	// Execute for each item
	for _, item := range items {
		// Prepare additional parameters for this iteration
		if each.As != "" {
			p.state.SetVariable(each.As, item)
		}

		// Prepare parameters for this iteration
		params, err := p.buildStepParameters(ctx, step)
		if err != nil {
			return nil, err
		}

		// Execute activity for this item
		result, err := p.activityExecutor.ExecuteActivity(ctx, step.Name, p.id, activity, params, p.state)
		if err != nil {
			return nil, err
		}
		results = append(results, result)
	}

	// Restore the original value of the "as" variable
	if originalAsValue != nil {
		p.state.SetVariable(each.As, originalAsValue)
	}

	// Store result directly in path variables if specified
	if step.Store != "" {
		varName := strings.TrimPrefix(step.Store, "state.")
		p.state.SetVariable(varName, results)
	}
	return results, nil
}

// resolveEachItems resolves the array of items from either a direct array or a Risor expression
func (p *Path) resolveEachItems(ctx context.Context, each *Each) ([]any, error) {
	// Array of strings
	if strArray, ok := each.Items.([]string); ok {
		var items []any
		for _, item := range strArray {
			items = append(items, item)
		}
		return items, nil
	}

	// Array of any
	if items, ok := each.Items.([]any); ok {
		return items, nil
	}

	// Handle script expression
	if codeStr, ok := each.Items.(string); ok {
		if strings.HasPrefix(codeStr, "$(") {
			if !strings.HasSuffix(codeStr, ")") {
				return nil, fmt.Errorf("invalid script expression for 'each' block: %s", codeStr)
			}
			return p.evaluateExpression(ctx, codeStr)
		}
	}

	// Consider it an array of one item
	return []any{each.Items}, nil
}

// evaluateExpression evaluates a Risor expression and returns the result as an array
func (p *Path) evaluateExpression(ctx context.Context, codeStr string) ([]any, error) {
	code := strings.TrimSuffix(strings.TrimPrefix(codeStr, "$("), ")")
	compiledScript, err := p.scriptCompiler.Compile(ctx, code)
	if err != nil {
		p.logger.Error("failed to compile 'each' expression", "error", err)
		return nil, fmt.Errorf("failed to compile expression: %w", err)
	}
	result, err := compiledScript.Evaluate(ctx, p.buildScriptGlobals())
	if err != nil {
		p.logger.Error("failed to evaluate 'each' expression", "error", err)
		return nil, fmt.Errorf("failed to evaluate expression: %w", err)
	}
	return result.Items()
}

// calculateBackoffDelay calculates the backoff delay for retry attempts
func (p *Path) calculateBackoffDelay(attempt int, retryConfig *RetryConfig) time.Duration {
	baseDelay := retryConfig.BaseDelay
	if baseDelay <= 0 {
		baseDelay = 1 * time.Second // Default base delay
	}

	backoffRate := retryConfig.BackoffRate
	if backoffRate <= 0 {
		backoffRate = 2.0 // Default backoff rate
	}

	// Exponential backoff
	delay := time.Duration(float64(baseDelay) * float64(int64(1)<<(attempt-1)))
	if backoffRate != 2.0 {
		// Use custom backoff rate instead of power of 2
		multiplier := 1.0
		for i := 1; i < attempt; i++ {
			multiplier *= backoffRate
		}
		delay = time.Duration(float64(baseDelay) * multiplier)
	}

	// Apply max delay cap if configured
	if retryConfig.MaxDelay > 0 && delay > retryConfig.MaxDelay {
		delay = retryConfig.MaxDelay
	}

	// Add jitter if configured
	if retryConfig.JitterStrategy == JitterFull {
		// Full jitter: randomize between 0 and calculated delay
		jitterRange := float64(delay)
		delay = time.Duration(rand.Float64() * jitterRange)
	}

	if delay < 0 {
		delay = baseDelay
	}

	return delay
}

// findMatchingRetryConfig finds the first retry configuration that matches the given error
func (p *Path) findMatchingRetryConfig(err error, retryConfigs []*RetryConfig) *RetryConfig {
	for _, config := range retryConfigs {
		// If no error types are explicitly specified, that equates to ErrorTypeAll
		if len(config.ErrorEquals) == 0 {
			if MatchesErrorType(err, ErrorTypeAll) {
				return config
			}
		}
		// Check if error matches any of the specified error types
		for _, errorType := range config.ErrorEquals {
			if MatchesErrorType(err, errorType) {
				return config
			}
		}
	}
	return nil
}

// executeCatchHandler executes catch handling logic when an error occurs
func (p *Path) executeCatchHandler(step *Step, err error) (any, error) {
	wErr := ClassifyError(err)
	// Find matching catch configuration
	for _, catchConfig := range step.Catch {
		for _, errorType := range catchConfig.ErrorEquals {
			if MatchesErrorType(err, errorType) {
				// Found a matching catch handler
				p.logger.Info("executing catch handler",
					"step_name", step.Name,
					"error_type", wErr.Type,
					"next_step", catchConfig.Next)

				// Create error output
				errorOutput := wErr.ToErrorOutput()

				// Store error if specified
				if catchConfig.Store != "" {
					resultPath := strings.TrimPrefix(catchConfig.Store, "state.")
					if resultPath != "" {
						p.state.SetVariable(resultPath, errorOutput)
					}
				}

				// Transition to the catch step
				nextStep, ok := p.workflow.GetStep(catchConfig.Next)
				if !ok {
					return nil, fmt.Errorf("catch handler step %q not found", catchConfig.Next)
				}

				// Update current step to the catch handler step
				p.currentStep = nextStep

				// Return a special marker to indicate successful catch handling
				// The main execution loop will continue with the new step
				return catchErrorSentinel, nil
			}
		}
	}
	// No matching catch handler found
	return nil, err
}

// buildScriptGlobals creates globals used for script execution
func (p *Path) buildScriptGlobals() map[string]any {
	return map[string]any{
		"inputs": copyMap(p.state.inputs),
		"state":  copyMap(p.state.variables),
	}
}

// buildStepParameters creates a parameter map by evaluating templates and script expressions
func (p *Path) buildStepParameters(ctx context.Context, step *Step) (map[string]interface{}, error) {
	params := make(map[string]interface{}, len(step.Parameters))
	for name, value := range step.Parameters {
		evaluated, err := p.evaluateParameterValue(ctx, value, step.Name, name)
		if err != nil {
			return nil, err
		}
		params[name] = evaluated
	}
	return params, nil
}

// evaluateParameterValue evaluates a parameter value, handling both script expressions and templates
func (p *Path) evaluateParameterValue(ctx context.Context, value interface{}, stepName, paramName string) (interface{}, error) {
	// If the parameter is a map, recursively evaluate the values
	if mapValue, ok := value.(map[string]any); ok {
		outMap := make(map[string]any, len(mapValue))
		for key, value := range mapValue {
			evaluated, err := p.evaluateParameterValue(ctx, value, stepName, key)
			if err != nil {
				return nil, err
			}
			outMap[key] = evaluated
		}
		return outMap, nil
	}

	strValue, ok := value.(string)
	if !ok {
		return value, nil
	}

	// Handle script expressions $(code) - these return actual values, not strings
	if strings.HasPrefix(strValue, "$(") && strings.HasSuffix(strValue, ")") {
		codeStr := strings.TrimPrefix(strValue, "$(")
		codeStr = strings.TrimSuffix(codeStr, ")")

		// Compile and evaluate the script
		compiledScript, err := p.scriptCompiler.Compile(ctx, codeStr)
		if err != nil {
			return nil, fmt.Errorf("failed to compile script expression in parameter %q of step %q: %w",
				paramName, stepName, err)
		}

		result, err := compiledScript.Evaluate(ctx, p.buildScriptGlobals())
		if err != nil {
			return nil, fmt.Errorf("failed to evaluate script expression in parameter %q of step %q: %w",
				paramName, stepName, err)
		}

		// Return the actual value from the script
		return result.Value(), nil
	}

	// Handle template strings. Detect if they are present by looking for the
	// "${" prefix of a template variable.
	if strings.Contains(strValue, "${") {
		evaluated, err := p.evaluateTemplate(ctx, strValue)
		if err != nil {
			return nil, fmt.Errorf("failed to evaluate parameter template %q in step %q: %w",
				paramName, stepName, err)
		}
		return evaluated, nil
	}

	// Return value as-is
	return value, nil
}
