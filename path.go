package workflow

import (
	"context"
	"fmt"
	"log/slog"
	"math/rand/v2"
	"strings"
	"time"

	"github.com/deepnoodle-ai/workflow/retry"
	"github.com/deepnoodle-ai/workflow/script"
	"github.com/deepnoodle-ai/workflow/state"
)

// ActivityExecutor provides a simplified interface for executing activities with logging and checkpointing
type ActivityExecutor interface {
	// ExecuteActivity runs an activity with automatic logging and checkpointing
	ExecuteActivity(ctx context.Context, stepName, pathID string, activity Activity, params map[string]interface{}) (interface{}, error)
}

// PathOptions contains all dependencies needed by a Path, injected at construction
type PathOptions struct {
	Workflow           *Workflow
	ActivityRegistry   map[string]Activity
	Logger             *slog.Logger
	Formatter          WorkflowFormatter
	State              state.State
	ActivityExecutor   ActivityExecutor
	UpdatesChannel     chan<- PathSnapshot
	ScriptCompiler     script.Compiler
	ExecutionCallbacks ExecutionCallbacks
}

// PathSpec specifies how to create a new path (ID generated by Execution)
type PathSpec struct {
	Step *Step
}

// PathSnapshot represents a snapshot of path state for communication
type PathSnapshot struct {
	PathID          string
	Status          PathStatus
	StepName        string
	StepOutput      any
	NewPaths        []PathSpec        // Specifications for new paths, not Path objects
	VariableUpdates []*VariableUpdate // Variables to mutate from step execution
	Error           error
	Timestamp       time.Time
	StartTime       time.Time
	EndTime         time.Time
}

type VariableUpdateType string

const (
	VariableUpdateTypeSet    VariableUpdateType = "set"
	VariableUpdateTypeDelete VariableUpdateType = "delete"
)

// VariableUpdate represents a variable update from a step execution
type VariableUpdate struct {
	Name  string
	Type  VariableUpdateType
	Value interface{}
}

// Path represents an execution path through a workflow with owned state
type Path struct {
	// Owned state
	id          string
	currentStep *Step
	status      PathStatus
	stepOutputs map[string]any
	startTime   time.Time
	endTime     time.Time

	// Injected dependencies (immutable after construction)
	workflow           *Workflow
	activityRegistry   map[string]Activity
	state              state.State
	activityExecutor   ActivityExecutor
	logger             *slog.Logger
	formatter          WorkflowFormatter
	updates            chan<- PathSnapshot
	scriptCompiler     script.Compiler
	executionCallbacks ExecutionCallbacks
}

// NewPath creates a new execution path with options pattern
func NewPath(id string, step *Step, opts PathOptions) *Path {
	return &Path{
		id:                 id,
		currentStep:        step,
		status:             PathStatusPending,
		stepOutputs:        make(map[string]any),
		startTime:          time.Now(),
		workflow:           opts.Workflow,
		activityRegistry:   opts.ActivityRegistry,
		state:              opts.State,
		activityExecutor:   opts.ActivityExecutor,
		logger:             opts.Logger.With("path_id", id),
		formatter:          opts.Formatter,
		updates:            opts.UpdatesChannel,
		scriptCompiler:     opts.ScriptCompiler,
		executionCallbacks: opts.ExecutionCallbacks,
	}
}

// ID returns the path ID
func (p *Path) ID() string {
	return p.id
}

// CurrentStep returns the current step in the path
func (p *Path) CurrentStep() *Step {
	return p.currentStep
}

// Snapshot returns a snapshot of the current path state
func (p *Path) Snapshot() PathSnapshot {
	stepOutputs := make(map[string]any)
	for k, v := range p.stepOutputs {
		stepOutputs[k] = v
	}
	return PathSnapshot{
		PathID:    p.id,
		Status:    p.status,
		StepName:  p.currentStep.Name,
		StartTime: p.startTime,
		EndTime:   p.endTime,
		Timestamp: time.Now(),
	}
}

// Run executes the path until completion or error
func (p *Path) Run(ctx context.Context) error {
	p.status = PathStatusRunning

	for {
		// Check for context cancellation
		select {
		case <-ctx.Done():
			return ctx.Err()
		default:
		}

		// Execute the current step
		currentStep := p.currentStep
		result, variableUpdates, err := p.executeStep(ctx, currentStep)
		if err != nil {
			p.status = PathStatusFailed
			p.endTime = time.Now()
			p.updates <- PathSnapshot{
				PathID:    p.id,
				Status:    p.status,
				StepName:  currentStep.Name,
				Error:     err,
				StartTime: p.startTime,
				EndTime:   p.endTime,
				Timestamp: time.Now(),
			}
			return err
		}

		// Store step output
		p.stepOutputs[currentStep.Name] = result

		// Handle path branching
		newPathSpecs, err := p.handleBranching(ctx)
		if err != nil {
			p.status = PathStatusFailed
			p.endTime = time.Now()
			p.updates <- PathSnapshot{
				PathID:    p.id,
				Status:    p.status,
				StepName:  currentStep.Name,
				Error:     err,
				StartTime: p.startTime,
				EndTime:   p.endTime,
				Timestamp: time.Now(),
			}
			return err
		}

		// This path is complete if there are:
		//  A) no new paths
		//  B) multiple paths (branching)
		isDone := len(newPathSpecs) == 0 || len(newPathSpecs) > 1

		if isDone {
			p.status = PathStatusCompleted
			p.endTime = time.Now()
		}

		// Send snapshot update
		var pathsToCreate []PathSpec
		if len(newPathSpecs) > 1 {
			pathsToCreate = newPathSpecs
		}

		p.updates <- PathSnapshot{
			PathID:          p.id,
			Status:          p.status,
			StepName:        currentStep.Name,
			StepOutput:      result,
			NewPaths:        pathsToCreate,
			VariableUpdates: variableUpdates,
			StartTime:       p.startTime,
			EndTime:         p.endTime,
			Timestamp:       time.Now(),
		}

		if isDone {
			return nil
		}

		// Continue with the single path
		p.currentStep = newPathSpecs[0].Step
	}
}

// executeStep executes a single workflow step
func (p *Path) executeStep(ctx context.Context, step *Step) (any, []*VariableUpdate, error) {
	p.logger.Info("executing step", "step_name", step.Name)

	// Print step start if formatter is available
	if p.formatter != nil {
		p.formatter.PrintStepStart(step.Name, step.Activity)
	}

	var result any
	var variableUpdates []*VariableUpdate
	var err error

	// Execute with retry logic if configured
	retryConfig := step.Retry
	if retryConfig != nil && retryConfig.MaxRetries > 0 {
		result, variableUpdates, err = p.executeStepWithRetry(ctx, step, retryConfig)
	} else {
		result, variableUpdates, err = p.executeStepOnce(ctx, step)
	}

	if err != nil {
		// Print step error if formatter is available
		if p.formatter != nil {
			p.formatter.PrintStepError(step.Name, err)
		}
		return nil, variableUpdates, err
	}

	// Store step result in state if not an each step (each steps handle their own storage)
	if step.Each == nil {
		// Store the result in a state variable if specified
		if varName := step.Store; varName != "" {
			// For script steps, store the actual converted value; for other steps, store the content
			var valueToStore interface{}
			if result != nil {
				valueToStore = result
			}
			variableUpdates = append(variableUpdates, &VariableUpdate{
				Name:  varName,
				Type:  VariableUpdateTypeSet,
				Value: valueToStore,
			})
			p.logger.Info("step result prepared for storage",
				"variable_name", varName, "value", valueToStore)
		}
	}

	// Print step output if formatter is available
	if p.formatter != nil {
		p.formatter.PrintStepOutput(step.Name, result.(string))
	}

	return result, variableUpdates, nil
}

// determineStepType determines the type of step based on its configuration
func determineStepType(step *Step) string {
	if step.Each != nil {
		return "each"
	}
	if step.Activity == "script" {
		return "script"
	}
	if step.Activity != "" {
		return "activity"
	}
	return "unknown"
}

// copyMapAny creates a shallow copy of a map[string]any
func copyMapAny(m map[string]any) map[string]any {
	if m == nil {
		return nil
	}
	result := make(map[string]any, len(m))
	for k, v := range m {
		result[k] = v
	}
	return result
}

// executeStepOnce executes a step once without retry logic
func (p *Path) executeStepOnce(ctx context.Context, step *Step) (any, []*VariableUpdate, error) {
	// Handle steps with "each" blocks
	if step.Each != nil {
		return p.executeStepEach(ctx, step)
	}

	// Use Activity interface
	activityName := step.Activity
	if activityName == "" {
		return nil, nil, fmt.Errorf("no activity specified for step %q", step.Name)
	}

	// Look up activity in registry
	activity, ok := p.activityRegistry[activityName]
	if !ok {
		return nil, nil, fmt.Errorf("activity %q not found for step %q", activityName, step.Name)
	}

	// Prepare parameters by evaluating templates
	params := make(map[string]interface{})
	for name, value := range step.Parameters {
		if strValue, ok := value.(string); ok && strings.Contains(strValue, "${") {
			evaluated, err := p.evaluateTemplate(ctx, strValue)
			if err != nil {
				return nil, nil, fmt.Errorf("failed to evaluate parameter template %q in step %q: %w",
					name, step.Name, err)
			}
			params[name] = evaluated
		} else {
			params[name] = value
		}
	}

	// Execute activity with logging and checkpointing
	result, err := p.activityExecutor.ExecuteActivity(ctx, step.Name, p.id, activity, params)
	if err != nil {
		return nil, nil, fmt.Errorf("activity execution failed: %w", err)
	}

	return result, nil, nil
}

// executeStepWithRetry executes a step with retry logic
func (p *Path) executeStepWithRetry(ctx context.Context, step *Step, retryConfig *RetryConfig) (any, []*VariableUpdate, error) {
	var lastErr error

	for attempt := 0; attempt <= retryConfig.MaxRetries; attempt++ {
		if attempt > 0 {
			// Calculate backoff delay
			delay := calculateBackoffDelay(attempt, retryConfig)
			p.logger.Info("retrying step",
				"step_name", step.Name,
				"attempt", attempt+1,
				"max_attempts", retryConfig.MaxRetries+1,
				"delay", delay)

			select {
			case <-ctx.Done():
				return nil, nil, ctx.Err()
			case <-time.After(delay):
			}
		}

		// Create timeout context if configured
		stepCtx := ctx
		var cancel context.CancelFunc
		if retryConfig.Timeout > 0 {
			stepCtx, cancel = context.WithTimeout(ctx, retryConfig.Timeout)
		}

		result, variableUpdates, lastErr := p.executeStepOnce(stepCtx, step)

		if cancel != nil {
			cancel()
		}

		if lastErr == nil {
			if attempt > 0 {
				p.logger.Info("step retry succeeded",
					"step_name", step.Name,
					"successful_attempt", attempt+1)
			}
			return result, variableUpdates, nil
		}

		// Check if error is recoverable
		if !retry.IsRecoverable(lastErr) {
			p.logger.Info("step failed with non-recoverable error, not retrying",
				"step_name", step.Name,
				"error", lastErr.Error())
			return nil, nil, lastErr
		}

		p.logger.Warn("step failed with recoverable error",
			"step_name", step.Name,
			"attempt", attempt+1,
			"error", lastErr.Error())
	}

	return nil, nil, fmt.Errorf("step %q failed after %d attempts: %w", step.Name, retryConfig.MaxRetries+1, lastErr)
}

// handleBranching evaluates conditions and creates path specs for branching
func (p *Path) handleBranching(ctx context.Context) ([]PathSpec, error) {
	edges := p.currentStep.Next
	if len(edges) == 0 {
		return nil, nil // No outgoing edges means this path is complete
	}

	// Evaluate conditions and collect matching edges
	var matchingEdges []*Edge
	for _, edge := range edges {
		if edge.Condition == "" {
			matchingEdges = append(matchingEdges, edge)
			continue
		}
		match, err := p.evaluateCondition(ctx, edge.Condition)
		if err != nil {
			return nil, fmt.Errorf("failed to evaluate condition %q in step %q: %w",
				edge.Condition, p.currentStep.Name, err)
		}
		if match {
			matchingEdges = append(matchingEdges, edge)
		}
	}

	// Create path specs for each matching edge
	var pathSpecs []PathSpec
	for _, edge := range matchingEdges {
		nextStep, ok := p.workflow.Get(edge.Step)
		if !ok {
			return nil, fmt.Errorf("next step not found: %s", edge.Step)
		}
		pathSpecs = append(pathSpecs, PathSpec{Step: nextStep})
	}
	return pathSpecs, nil
}

// evaluateCondition evaluates a workflow condition
func (p *Path) evaluateCondition(ctx context.Context, condition string) (bool, error) {
	// Handle simple boolean conditions
	switch strings.ToLower(strings.TrimSpace(condition)) {
	case "true":
		return true, nil
	case "false":
		return false, nil
	}

	// Handle script expressions wrapped in $()
	codeStr := condition
	if strings.HasPrefix(codeStr, "$(") && strings.HasSuffix(codeStr, ")") {
		codeStr = strings.TrimPrefix(codeStr, "$(")
		codeStr = strings.TrimSuffix(codeStr, ")")
	}

	// Compile the script
	compiledScript, err := p.scriptCompiler.Compile(ctx, codeStr)
	if err != nil {
		return false, fmt.Errorf("failed to compile condition: %w", err)
	}

	// Evaluate the condition
	result, err := compiledScript.Evaluate(ctx, p.buildScriptGlobals())
	if err != nil {
		return false, fmt.Errorf("failed to evaluate condition: %w", err)
	}

	// Convert result to boolean
	return result.IsTruthy(), nil
}

// evaluateTemplate evaluates a template string
func (p *Path) evaluateTemplate(ctx context.Context, template string) (string, error) {
	if strings.HasPrefix(template, "$(") && strings.HasSuffix(template, ")") {
		template = strings.TrimPrefix(template, "$(")
		template = strings.TrimSuffix(template, ")")
	}
	tmpl, err := script.NewTemplate(p.scriptCompiler, template)
	if err != nil {
		return "", fmt.Errorf("failed to compile template: %w", err)
	}
	return tmpl.Eval(ctx, p.buildScriptGlobals())
}

// executeStepEach handles the execution of a step that has an each block
func (p *Path) executeStepEach(ctx context.Context, step *Step) (any, []*VariableUpdate, error) {
	each := step.Each

	// Resolve the items to iterate over
	items, err := p.resolveEachItems(ctx, each)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to resolve each items: %w", err)
	}

	// Execute the step for each item and capture the results
	results := make([]any, 0, len(items))

	// Look up activity in registry
	activityName := step.Activity
	if activityName == "" {
		return nil, nil, fmt.Errorf("no activity specified for step %q", step.Name)
	}

	activity, ok := p.activityRegistry[activityName]
	if !ok {
		return nil, nil, fmt.Errorf("activity %q not found for step %q", activityName, step.Name)
	}

	// Execute for each item
	for _, item := range items {
		// Prepare parameters for this iteration
		params := make(map[string]interface{})
		for name, value := range step.Parameters {
			if strValue, ok := value.(string); ok && strings.Contains(strValue, "${") {
				evaluated, err := p.evaluateTemplate(ctx, strValue)
				if err != nil {
					return nil, nil, fmt.Errorf("failed to evaluate parameter template %q in step %q: %w",
						name, step.Name, err)
				}
				params[name] = evaluated
			} else {
				params[name] = value
			}
		}

		// Add current item to parameters
		if each.As != "" {
			params[each.As] = item
		}

		// Execute activity for this item
		result, err := p.activityExecutor.ExecuteActivity(ctx, step.Name, p.id, activity, params)
		if err != nil {
			return nil, nil, err
		}

		results = append(results, result)
	}

	// Combine the results into one string which we put in a single task result
	itemTexts := make([]string, 0, len(results))
	for i, result := range results {
		var itemText string
		if each.As != "" {
			itemText = fmt.Sprintf("# %s: %s\n\n%v", each.As, items[i], result)
		} else {
			itemText = fmt.Sprintf("# %s\n\n%v", items[i], result)
		}
		itemTexts = append(itemTexts, itemText)
	}

	var variableUpdates []*VariableUpdate
	if step.Store != "" {
		variableUpdates = append(variableUpdates, &VariableUpdate{
			Name:  step.Store,
			Type:  VariableUpdateTypeSet,
			Value: itemTexts,
		})
	}

	return strings.Join(itemTexts, "\n\n"), variableUpdates, nil
}

// resolveEachItems resolves the array of items from either a direct array or a Risor expression
func (p *Path) resolveEachItems(ctx context.Context, each *Each) ([]any, error) {
	// Array of strings
	if strArray, ok := each.Items.([]string); ok {
		var items []any
		for _, item := range strArray {
			items = append(items, item)
		}
		return items, nil
	}

	// Array of any
	if items, ok := each.Items.([]any); ok {
		return items, nil
	}

	// Handle script expression
	if codeStr, ok := each.Items.(string); ok {
		if strings.HasPrefix(codeStr, "$(") && strings.HasSuffix(codeStr, ")") {
			return p.evaluateExpression(ctx, codeStr)
		}
	}
	return nil, fmt.Errorf("unsupported value for 'each' block (got %T)", each.Items)
}

// evaluateExpression evaluates a Risor expression and returns the result as an array
func (p *Path) evaluateExpression(ctx context.Context, codeStr string) ([]any, error) {
	code := strings.TrimSuffix(strings.TrimPrefix(codeStr, "$("), ")")
	compiledScript, err := p.scriptCompiler.Compile(ctx, code)
	if err != nil {
		p.logger.Error("failed to compile 'each' expression", "error", err)
		return nil, fmt.Errorf("failed to compile expression: %w", err)
	}
	result, err := compiledScript.Evaluate(ctx, p.buildScriptGlobals())
	if err != nil {
		p.logger.Error("failed to evaluate 'each' expression", "error", err)
		return nil, fmt.Errorf("failed to evaluate expression: %w", err)
	}
	return result.Items()
}

// calculateBackoffDelay calculates the backoff delay for retry attempts
func calculateBackoffDelay(attempt int, retryConfig *RetryConfig) time.Duration {
	baseDelay := retryConfig.BaseDelay
	if baseDelay <= 0 {
		baseDelay = 2 * time.Second // Default base delay
	}

	// Exponential backoff with jitter
	delay := time.Duration(float64(baseDelay) * float64(int64(1)<<(attempt-1)))

	// Apply max delay cap if configured
	if retryConfig.MaxDelay > 0 && delay > retryConfig.MaxDelay {
		delay = retryConfig.MaxDelay
	}

	// Add 10% jitter to prevent thundering herd
	jitter := time.Duration(float64(delay) * 0.1 * (2*rand.Float64() - 1))
	delay += jitter

	if delay < 0 {
		delay = baseDelay
	}

	return delay
}

// buildScriptGlobals creates globals used for script execution
func (p *Path) buildScriptGlobals() map[string]any {
	return map[string]any{
		"inputs": p.state.GetInputs(),
		"state":  p.state.GetVariables(),
	}
}
